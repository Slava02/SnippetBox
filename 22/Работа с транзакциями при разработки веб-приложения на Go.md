# Работа с транзакциями при разработки веб-приложения на Go

---
Вы могли заметить, что пакет `database/sql` по сути предоставляет стандартный интерфейс между нашим приложением на Go и миром баз данных SQL.

Пока вы используете пакет `database/sql`, ваш код будет работать с любым типом SQL базы данных — будь то MySQL, PostgreSQL, SQLite или что-то еще. Это означает, что ваше приложение не зависит от определённой базы данных, которую вы используете в настоящее время. Следовательно, вы можете менять базу данных в будущем, не переписывая весь код (за исключением специфических особенностей драйвера и SQL запросов).


Важно отметить, что, хотя пакет `database/sql` обычно хорошо справляется предоставляя стандартный интерфейс для работы с **SQL базами данных**, существуют некоторые особенности в работе различных драйверов и баз данных. Всегда нужно ознакомиться с документацией к новому драйверу, чтобы понять его особенности перед началом его использования.

## NULL значения в SQL и Golang

Одним из недостатков Go является тот факт, что данный язык не очень хорошо справляется с управлением `NULL` значениями в записях базы данных.

Предположим, что столбец `title` в таблице `snippets` содержит значением `NULL` в определенном ряду. Если выполнить запрос к данному ряду, то метод `rows.Scan()` вернет ошибку, потому что он не может конвертировать `NULL` в [строку](https://golangs.org/string "строки в golang").

```sql
sql: Scan error on column index 1: unsupported Scan, storing driver.Value type
&lt;nil&gt; into type *string
```
Грубо говоря, исправить это можно, изменив сканируемое поле из `string` на тип `sql.NullString`. В качестве примера можете ознакомиться с [этим gist](https://gist.github.com/alexedwards/dc3145c8e2e6d2fd6cd9).

Как правило, проще всего вообще избегать значений `NULL`. Поставьте ограничения `NOT NULL` для всех столбцов базы данных, как мы это сделали в этом курсе.

## Работа с SQL транзакциями в Go

Важно понимать, что вызовы `Exec()`, `Query()` и `QueryRow()` могут использовать любое соединение из пула `sql.DB`. Даже если в вашем коде есть два вызова `Exec()` рядом друг с другом, нет гарантии, что они будут использовать одно и то же [соединение с базой данных](https://golangs.org/mysql-connection-pool-go "подключение к mysql в golang").

Иногда это неприемлемо. Например, если заблокировать таблицу с помощью MySQL команды `LOCK TABLES`, нужно вызвать `UNLOCK TABLES` точно для того же соединения, чтобы избежать блокировки всего процесса работы с данной таблицей из других соединений.

Для гарантии использования одного и того же соединения можно заключить в транзакцию несколько SQL-операторов.

Вот основной шаблон метода в нашей тестовой [модели](https://golangs.org/designing-a-database-model "модель базы данных"):

```go
type ExampleModel struct {
    DB *sql.DB
}

func (m *ExampleModel) ExampleTransaction() error {
    // Вызов метода Begin() в пуле соединений создает новый объект sql.Tx 
    // который представляет текущую транзакцию к базы данных.
    tx, err := m.DB.Begin()
    if err != nil {
        return err
    }

    // Вызываем Exec() для транзакции, передавая оператор и любые другие 
    // параметры. Важно отметить, что tx.Exec() вызывается для 
    // только что созданного объекта транзакции, а НЕ для пула соединений. Хотя мы 
    // здесь используем tx.Exec(), вы также можете использовать tx.Query() и tx.QueryRow() 
    // таким же образом
    _, err = tx.Exec("INSERT INTO ...")
    if err != nil {
        // Если возникла ошибка, вызываем метод tx.Rollback() для 
        // транзакции. Он прервет транзакцию и 
        // в базу данных не будут внесены изменения.
        tx.Rollback()
        return err
    }

    // Точно так же выполняется другая транзакция.
    _, err = tx.Exec("UPDATE ...")
    if err != nil {
        tx.Rollback()
        return err
    }

    // Если ошибок нет, то запрос транзакции может быть
    // выполнен в базе данных с помощью метода tx.Commit(). Очень важно ВСЕГДА 
    // вызывать Rollback() или Commit() в конце функции перед "return". Если вы 
    // этого не сделаете, соединение останется открытым и не будет возвращено 
    // в пул соединений. Это может привести к достижению максимального лимита соединений и исчерпанию ресурсов.
    err = tx.Commit()
    return err
}
```
Транзакции очень полезны, если нужно выполнять несколько SQL запросов как *одно единое действие*. Даже если возникнет ошибка, но пока вы используете метод `tx.Rollback()`, транзакция гарантирует, что:

-   *Все* запросы выполняются успешно… или
-   *Никакие* запросы не выполняются, и база данных остается неизменной.

## Управление SQL соединениями в Go

Пул подключений `sql.DB` состоит из соединений, которые либо **простаивают**, либо **используются**. По умолчанию нет ограничения для максимального количества открытых подключений (простаивающих + используемых) одновременно, но максимальное количество неактивных подключений в пуле по умолчанию равно 2.

Эти значения можно изменить с помощью [методов](https://golangs.org/methods "создать метод в golang") `SetMaxOpenConns()` и `SetMaxIdleConns()`. Например:

```go
db, err := sql.Open("mysql", *dsn)
if err != nil {
    log.Fatal(err)
}

// Устанавливаем максимальное количество одновременно открытых (простаивающих + используемых) соединений.
// Указание этого значения меньше или равного 0 будет означать, что ограничений нет. Если максимальное 
// количество открытых подключений достигнуто и все они используются, но нам требуется новое подключение, 
// тогда Go будет ждать, пока одно из подключений не освободится. С точки зрения 
// пользователя это означает, что HTTP запрос будет загружаться до тех пор, пока 
// соединение с базой данных не станет доступным. По сути, у пользователя зависнет сайт.
db.SetMaxOpenConns(100)

// Устанавливаем максимальное количество неактивных соединений в пуле. Указание этого 
// значения меньше или равного 0 будет означать, что неактивные соединения не будут создаваться.
// Каждый запрос создаст новое подключение и сразу начнет с ней работу.
db.SetMaxIdleConns(5)
```
>[!Tip]
> **Использование данных методов сопровождается предупреждением:** у базы данных скорее всего есть ограничение на максимальное количество подключений.

Например, ограничение по умолчанию для MySQL равно **151**. Таким образом, если настроить `SetMaxOpenConns()` полностью неограниченным или установить значение больше 151 подключений, это может [привести к ошибке](https://golangs.org/errors "обработка ошибок в golang") `"too many connections"` при высокой нагрузке. Чтобы эта ошибка не возникла, нужно установить максимальное значение открытых подключений ниже 151.

Однако, так появляется другая проблема. Когда достигается предел `SetMaxOpenConns()`, любые новые задачи к базы данных, которые приложению необходимо выполнить, будут ждать, пока соединение не станет свободным и продолжить работу.

Для некоторых приложений такое поведение может быть нормальным, но **веб-приложению** лучше сразу записать ошибку в журнал как `"too many connections"` и отправлять пользователю ответ `500 Internal Server Error` вместо того, чтобы их HTTP запрос завис и ожидал освобождения нового подключения к базе данных.

По этой причине мы не использовали методы `SetMaxOpenConns()` и `SetMaxIdleConns()` в нашем приложении все настройки по умолчанию. Такие моменты лучше настраивать в конфигурационном файле самого MySQL.

_Полезные ссылки:_
[sql транзакции](https://www.google.com/search?sca_esv=c2f96fb7793eaf7e&sca_upv=1&q=sql+%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8&tbm=vid&source=lnms&prmd=ivsnbmt&sa=X&sqi=2&ved=2ahUKEwiJicyE-IeGAxW-AxAIHdSjDLIQ0pQJegQIERAB&biw=1459&bih=752&dpr=1.25#fpstate=ive&vld=cid:48b0bf2c,vid:H0cl2DMNdqo,st:0)