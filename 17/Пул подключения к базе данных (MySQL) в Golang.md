# Пул подключения к базе данных (MySQL) в Golang
---
## Создание пула подключений к MySQL в Go

Сейчас наша база данных настроена и установлен **драйвер для работы с MySQL из Golang**, теперь можно попробовать **подключиться к базе данных из веб-приложения**.
```go
// Функция sql.Open() инициализирует новый объект sql.DB, который по сути
// является пулом подключения к базе данных.
db, err := sql.Open("mysql", "web:pass@/snippetbox?parseTime=true")
if err != nil {
    ...
}
```
В этом коде есть несколько моментов, которые следует разобрать:

-   Первый параметр из `sql.Open()` представляет собой название драйвера (*в нашем случае это mysql*), а второй параметр — название источника данных (иногда он еще называется строкой подключения или DSN), которое описывает, как **подключиться к базе данных**;
-   Формат названия источника данных будет зависеть от того, какую базу данных и драйвер вы используете. Как правило, эту информацию можно найти в документации к вашему конкретному драйверу. Документацию по нашему MySQL-драйверу можно найти [здесь](https://github.com/go-sql-driver/mysql#dsn-data-source-name);
-   Часть с `parseTime=true` в приведенном выше DSN представляет собой специфичный для драйвера параметр, который указывает драйверу, что нужно преобразовывать SQL поля `TIME` и `DATE` в Go объекты [time.Time](https://golangs.org/go/time "дата и время в golang");
-   Функция `sql.Open()` возвращает объект [sql.DB](https://golang.org/pkg/database/sql/#DB). **Это не соединение с базой данных** — это **пул множества соединений**. Это важное различие нужно запомнить. Go управляет этими подключениями по мере необходимости, автоматически открывая и закрывая подключения к базе данных через драйвер;
-   Пул соединений безопасен для [конкурентного](https://golangs.org/goroutines "горутины") доступа, поэтому его можно спокойно использовать из [обработчиков маршрутов](https://golangs.org/routing-servemux "маршрутизация в golang") веб-приложений;
-   Пул соединений рассчитан на долгий срок службы. В веб-приложении, пул соединений обычно инициализируется в функции `main()`, а затем этот пул передается обработчикам. Не нужно вызывать `sql.Open()` в каждом обработчике — это будет пустой тратой памяти и сетевых ресурсов.

## Использование пула подключений в веб-приложении на Go

Разберем использование `sql.Open()` на практике. Откройте файл `main.go` и добавьте в него следующий код:

```go
package main

import (
	"database/sql" // Новый импорт
	"flag"
	"log"
	"net/http"
	"os"

	_ "github.com/go-sql-driver/mysql" // Новый импорт
)

type application struct {
	errorLog *log.Logger
	infoLog  *log.Logger
}

func main() {
	addr := flag.String("addr", ":4000", "Сетевой адрес веб-сервера")
	// Определение нового флага из командной строки для настройки MySQL подключения.
	dsn := flag.String("dsn", "web:pass@/snippetbox?parseTime=true", "Название MySQL источника данных")
	flag.Parse()

	infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
	errorLog := log.New(os.Stderr, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)

	// Чтобы функция main() была более компактной, мы поместили код для создания 
	// пула соединений в отдельную функцию openDB(). Мы передаем в нее полученный  
	// источник данных (DSN) из флага командной строки.
	db, err := openDB(*dsn)
	if err != nil {
		errorLog.Fatal(err)
	}

	// Мы также откладываем вызов db.Close(), чтобы пул соединений был закрыт 
	// до выхода из функции main().
	// Подробнее про defer: https://golangs.org/errors#defer
	defer db.Close()

	app := &application{
		errorLog: errorLog,
		infoLog:  infoLog,
	}

	srv := &http.Server{
		Addr:     *addr,
		ErrorLog: errorLog,
		Handler:  app.routes(),
	}

	infoLog.Printf("Запуск сервера на %s", *addr)
	// Поскольку переменная `err` уже объявлена в приведенном выше коде, нужно 
	// использовать оператор присваивания = 
	// вместо оператора := (объявить и присвоить)
	err = srv.ListenAndServe()
	errorLog.Fatal(err)
}

// Функция openDB() обертывает sql.Open() и возвращает пул соединений sql.DB 
// для заданной строки подключения (DSN).
func openDB(dsn string) (*sql.DB, error) {
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, err
	}
	if err = db.Ping(); err != nil {
		return nil, err
	}
	return db, nil
}
```
В этом коде есть несколько интересных моментов:

-   Обратите внимание, что в пути импорта mysql-драйвера есть префикс подчеркивания `_`. Причина в том, что файл `main.go` ничего не использует из пакета `mysql`. Если мы попытаемся импортировать его в обычном режиме без подчеркивания, то [компилятор](https://golangs.org/go-beginning#compiler "go компилятор") выдаст ошибку. Во время **импорта mysql-драйвера**, он в фоновом режиме выполнит функцию `init()`, которая необходима для дальнейшей работы с пакетом `database/sql`. Смысл такого трюка состоит в том, чтобы связать название пакета с пустым идентификатором. Это стандартная практика для большинства SQL драйверов в Go;
-   Функция `sql.Open()` не создает никаких подключений к базе данных. Все, что она делает, это **инициализирует пул подключений** для использования в будущем. Фактические подключения к базе данных устанавливаются лениво, если это впервые. Чтобы убедиться, что все настроено правильно, нужно использовать метод [db.Ping()](https://golang.org/pkg/database/sql/#DB.Ping) для **создания соединения с MySQL** и проверки на наличие ошибок;
-   На данный момент вызов `defer db.Close()` является излишним. Наше приложение завершается только от ручной комбинации на клавиатуре (то есть `Ctrl+C`) или фатальной ошибки которая автоматически вызовет `errorLog.Fatal()`. В обоих случаях программа немедленно завершает работу, а [отложенные функции](https://golangs.org/errors#defer "defer golang") никогда не будут запущены. Но использование `db.Close()` по **завершению работы с базой данных**, будет считаться хорошим тоном, и такой подход будет полезен в будущем, если вы добавите в свое приложение аккуратное завершение работы при возникновении фатальных ошибок.

### Тестирование подключения к MySQL из веб-приложения

Убедитесь, что все отредактированные файлы сохранены. Затем попробуйте запустить наше веб-приложение из терминала. Если всё прошло по плану, пул подключений должен быть установлен, а метод `db.Ping()` попробует **подключится к базе данных** без каких-либо ошибок. Если все в порядке, вы должны увидеть обычное [сообщение из логов](https://golangs.org/logging "логирование сообщений в golang"): *Запуск сервера на…* 

```shell
$ go run ./cmd/web
INFO	2021/01/27 18:40:01 Запуск сервера на :4000
```
Если приложение не запускается или появляется **сообщение об ошибке** `"Access denied..."`, как показано ниже, то проблема скорее всего связана с вашей строкой подключения (DSN). Проверьте правильность имени пользователя и пароля, разрешения пользователей и что ваш  MySQL сервер использует стандартные настройки.

Но, скорее всего вы **неправильно указали логин или пароль** от MySQL пользователя, пройдите еще раз прошлый урок по [настройки базы данных](https://golangs.org/mysql-web-site).

```shell
$ go run ./cmd/web
ERROR	2021/01/27 18:46:22 main.go:32: Error 1045: Access denied for user 'web'@'localhost' (using password: YES)
```
### Скачать исходный код

**Скачать**: [snippetbox-17.zip](https://golangs.org/wp-content/uploads/2021/01/snippetbox-17.zip)

![](https://golangify.com/wp-content/uploads/2021/01/v.jpg)

