
Давайте вдохнем в наш проект немного жизни и создадим красивую домашнюю страницу для нашего веб-приложения. В следующих нескольких уроках мы будем заниматься созданием страницы, которая выглядит следующим образом:

Для этого [создадим файл](https://golangs.org/go/filesystem "работа с файлами в golang") шаблона в папке `ui/html`

Добавим в него следующую **HTML разметку** для домашней страницы:
``` html
<!doctype html>
<html lang='en'>
    <head>
        <meta charset='utf-8'>
        <title>Домашняя страница - Snippetbox</title>
    </head>
    <body>
        <header>
            <h1><a href='/'>Snippetbox</a></h1>
        </header>
        <nav>
            <a href="/">Домашняя страница</a>
        </nav>
        <main>
            <h2>Последние заметки</h2>
            <p>Здесь пока ничего нет!</p>
        </main>
    </body>
</html>
```

> **На заметку**: В следующих уроках для файлов шаблонов мы будем использовать именование следующего формата `<название>.<роль>.tmpl`, где `<роль>` будет одно из трех `page`, `partial` или `layout`. Возможность определить роль шаблона из самого названия файла поможет нам, когда придет время создания кеша шаблонов.

Итак, теперь, когда мы **создали файл шаблона** с HTML разметкой для домашней страницы, возникает вопрос: как заставить обработчик главной страницы `home()`  показать его?

Для этого потребуется импортировать пакет Go [html/template](https://golang.org/pkg/html/template/), который предоставляет множество [функций](https://golangs.org/func "функции в golang") для безопасного чтения и **рендеринга HTML шаблонов**. Можно использовать функции из данного пакета для парсинга файла шаблона, а затем выполнить сам шаблон.

Продемонстрируем это в деле. Откройте файл `cmd/web/handlers.go` и добавьте следующий код:

```go
package main

import (
    "fmt"
    "html/template" // новый импорт
    "log"           // новый импорт
    "net/http"
    "strconv"
)

// Обработчик главной страницы.
func home(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}

	// Используем функцию template.ParseFiles() для чтения файла шаблона.
	// Если возникла ошибка, мы запишем детальное сообщение ошибки и
	// используя функцию http.Error() мы отправим пользователю
	// ответ: 500 Internal Server Error (Внутренняя ошибка на сервере)
	ts, err := template.ParseFiles("./ui/html/home.page.tmpl")
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Internal Server Error", 500)
		return
	}

	// Затем мы используем метод Execute() для записи содержимого
	// шаблона в тело HTTP ответа. Последний параметр в Execute() предоставляет
	// возможность отправки динамических данных в шаблон.
	err = ts.Execute(w, nil)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Internal Server Error", 500)
	}
}

...
```

Важно отметить, что [путь к файлу](https://golangs.org/user-home-directory), который вы передаете функции `template.ParseFiles()`, должен быть либо относительно вашей текущей рабочей папки, либо абсолютным путем. В приведенном выше коде мы указали путь относительно корня папки проекта.

Откройте страницу [http://127.0.0.1:4000](http://127.0.0.1:4000/) в браузере. Вы заметите, что домашняя страница начала приобретать новый вид:

![HTML шаблон для сайта на Golang](https://golangs.org/wp-content/uploads/2021/01/html-template.jpg)

При добавлении дополнительных страниц в веб-приложение будет использоваться некоторая общая стандартная HTML разметка, некий «**каркас**«. Данный каркас будет использован на каждой странице, в него будет входить например, заголовок, меню навигации и метаданные внутри HTML элемента `<head>`. По сути, у нас на таких страницах как «_Контакты_» и «_О проекте_» будет одна и та же HTML разметка кроме тех данных, что будут находится в теге `<body>`.

Чтобы избавить нас от лишнего набора текста и предотвратить дублирование одного и того же HTML в нескольких файлах, рекомендуется создать макет или **главный шаблон**, содержащий общую структуру, который затем можно дополнить данными из других файлов шаблона.

Создайте новый файл `ui/html/base.layout.tmpl`

Добавим следующую **основную HTML разметку** (которую мы хотим отображать на каждой странице):

```html
{{define "base"}}
<!doctype html>
<html lang='en'>
    <head>
        <meta charset='utf-8'>
        <title>{{template "title" .}} - Snippetbox</title>
    </head>
    <body>
        <header>
            <h1><a href='/'>Snippetbox</a></h1>
        </header>
        <nav>
            <a href='/'>Домашняя страница</a>
        </nav>
        <main>
            {{template "main" .}}
        </main>
    </body>
</html>
{{end}}
```

основной HTML каркас для отображения на каждой странице.

Внутри мы используем выражение `{{template "title" .}}` и `{{template "main" .}}`, чтобы обозначить, что мы хотим вызывать другие именованные шаблоны (под названием `title` и `main`) в определенной точке нашего HTML шаблона.

> **На заметку**: Если вам интересно, точка в конце выражения   `{{template "title" .}}` означает любые динамические данные, которые требуется передать для вызываемого шаблона. В будущих уроках мы поговорим об этом подробнее.

Теперь вернемся к файлу `ui/html/home.page.tmpl` и обновим этот файл для определения именованных блоков с контентом `title` и `main`, содержащих определенный контент для домашней страницы:

```html
{{template "base" .}}

{{define "title"}}Домашняя страницы{{end}}

{{define "main"}}
<h2>Последние заметки</h2>
<p>Пока здесь ничего нет!</p>
{{end}}
```

В верхней правой части этого файла находится, пожалуй, самый важный элемент — выражение `{{template "base" .}}`. Оно сообщает **Go шаблонизатору**, что при выполнении файла `home.page.tmpl` требуется вызвать указанный базовый-шаблон `base` который содержит основную HTML разметку.

Шаблон `base` содержит инструкции по вызову именованных блоков с контентом `title` и `main`. Поначалу это может показаться замкнутым кругом, но не волнуйтесь — на практике этот шаблон работает очень хорошо.

Когда все будет закончено, следующим шагом будет обновление кода в обработчике `home()`, чтобы тот загружал оба файла шаблонов:
```go
package main

...

// Обработчик главной странице.
func home(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}

	// Инициализируем срез содержащий пути к двум файлам. Обратите внимание, что
	// файл home.page.tmpl должен быть *первым* файлом в срезе.
	files := []string{
		"./ui/html/home.page.tmpl",
		"./ui/html/base.layout.tmpl",
	}

	// Используем функцию template.ParseFiles() для чтения файлов шаблона.
	// Если возникла ошибка, мы запишем детальное сообщение ошибки и
	// используя функцию http.Error() мы отправим пользователю
	// ответ: 500 Internal Server Error (Внутренняя ошибка на сервере)
	ts, err := template.ParseFiles(files...)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Internal Server Error", 500)
		return
	}

	// Затем мы используем метод Execute() для записи содержимого
	// шаблона в тело HTTP ответа. Последний параметр в Execute() предоставляет
	// возможность отправки динамических данных в шаблон.
	err = ts.Execute(w, nil)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Internal Server Error", 500)
	}
}

...
```
 именно каркас будет использоваться на определенной странице. Это очень полезно для больших приложений, где на разных страницах может потребоваться использование разных макетов.

## Разбиваем шаблон на части

Для некоторых приложений может потребоваться разбить определенные фрагменты HTML на части, которые можно повторно использовать на разных страницах или макетах. Для примера давайте создадим файл `partial`, содержащий HTML разметку подвала для веб-приложения.

Создайте новый файл `ui/html/footer.partial.tmpl` и добавьте именованный блок с контентом под названием `footer`

```html
{{define "footer"}}
<footer>Сайт создан на <strong>Golang</strong></footer>
{{end}}
```

Затем обновите файл шаблона `base`, чтобы он вызывал шаблон подвала, используя выражение `{{template "footer" .}}`.

```html
{{define "base"}}
<!doctype html>
<html lang='en'>
    <head>
        <meta charset='utf-8'>
        <title>{{template "title" .}} - Snippetbox</title>
    </head>
    
    <body>
        <header>
            <h1><a href='/'>Snippetbox</a></h1>
        </header>
        <nav>
            <a href='/'>Домашняя страница</a>
        </nav>
        
        <main>
            {{template "main" .}}
        </main>
        <!-- Вызываем шаблон подвала -->
        {{template "footer" .}}
    </body>
</html>
{{end}}
```

Под конец нам нужно обновить обработчик главной странице `home()`, чтобы он включал новый файл `ui/html/footer.partial.tmpl` при загрузки файлов шаблона:
```go
package main

...

// Обработчик главной странице.
func home(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}

	// Инициализируем срез содержащий пути к двум файлам. Обратите внимание, что
	// файл home.page.tmpl должен быть *первым* файлом в срезе.
	files := []string{
		"./ui/html/home.page.tmpl",
		"./ui/html/base.layout.tmpl",
		"./ui/html/footer.partial.tmpl",
	}

	ts, err := template.ParseFiles(files...)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Internal Server Error", 500)
		return
	}

	err = ts.Execute(w, nil)
	if err != nil {
		log.Println(err.Error())
		http.Error(w, "Internal Server Error", 500)
	}
}

...
```
После перезапуска веб-сервера, шаблон `base` должен вызвать шаблон `footer` и вставить его содержимое в себя вместо выражения `{{template "footer" .}}`. Домашняя страница должна выглядеть следующим образом:

![Шаблонизатор в Golang](https://golangs.org/wp-content/uploads/2021/01/html-template-with-footer.jpg)

В коде выше мы использовали выражение `{{template}}` для вызова определенного шаблона из другого шаблона. **Шаблонизатор в Go**, также предоставляет выражение `{{block}} ... {{end}}`, которое можно использовать вместо `{{template}}`.

Оно работает как `{{template}}`, за исключением того, что позволяет указать некоторое **содержимое по умолчанию**, если вызываемого шаблона нет в текущем наборе шаблонов.

Говоря о веб-приложении, это полезно, когда требуется предоставить некоторый контент по умолчанию например, **боковое меню сайта** (sidebar), которую отдельные страницы могут переписать по разному в зависимости от обстоятельств.

Синтаксически `{{block}}` выглядит следующим образом:
```html
{{define "base"}}
    <h1>Пример шаблона</h1>
    {{block "sidebar" .}}
        <p>Моя боковая панель!</p>
    {{end}}
{{end}}
```

Но, если хотите, вы можете не включать какой-либо контент по умолчанию между выражениями `{{block}}` и `{{end}}`. В этом случае вызванный шаблон действует как «необязательный». Если рассматриваемый шаблон есть в наборе шаблонов, в данном случае это `sidebar`, он будет отображен. Но если его нет, то ничего не будет отображаться.

### Скачать исходный код веб-приложения

**Скачать**: [snippetbox-7.zip](https://golangs.org/wp-content/uploads/2021/01/snippetbox-7.zip)
