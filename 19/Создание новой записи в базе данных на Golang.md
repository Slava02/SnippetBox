# Создание новой записи в базе данных на Golang
---
## Выполнение SQL запросов в Golang

Давайте обновим недавно [созданный метод](https://golangs.org/methods "методы в golang") `SnippetModel.Insert()` из файла `pkg/models/mysql/snippets.go`, чтобы он создавал новую запись в таблице `snippets`, и затем возвращал `id` типа [integer](https://golangs.org/integer "golang integer") для только что созданной записи.

```sql
INSERT INTO snippets (title, content, created, expires)
VALUES(?, ?, UTC_TIMESTAMP(), DATE_ADD(UTC_TIMESTAMP(), INTERVAL ? DAY))
```
Обратите внимание, что в этом запросе мы используем знак `?` для указания плейсхолдера для данных, которых требуется вставить в базу данных. Так как данные, которые мы будем использовать, в конечном итоге будут поступать к нам от пользователя из HTML формы, рекомендуется использовать плейсхолдеры вместо вставки данных напрямую в **SQL запросе**.

> Если вы не будете использовать плейсхолдеры, то вы рискуете оставить уязвимость в виде [SQL-инъекции](https://www.youtube.com/watch?v=4t16wXJXM-A).

## Выполнение SQL запроса

Go предоставляет три различных метода для выполнения запросов к [базе данных](https://golangs.org/mysql-web-site "MySQL база данных"):

-   [DB.Query()](https://golang.org/pkg/database/sql/#DB.Query) используется для `SELECT` запросов, которые возвращают несколько рядов данных из таблицы, например «*все записи за сегодня*«;
-   [DB.QueryRow()](https://golang.org/pkg/database/sql/#DB.QueryRow) используется для `SELECT` запросов, которые возвращают один ряд, например «*только одну запись у которой ID = 10*«;
-   [DB.Exec()](https://golang.org/pkg/database/sql/#DB.Exec) используется для операторов, которые не возвращают данные (вроде `INSERT` и `DELETE`). Добавление данных или их удаление из базы данных.

В нашем случае, подходящим инструментом будет `DB.Exec()`. Давайте перейдем к сути и посмотрим, как мы применим его в методе `SnippetModel.Insert()`. Подробности разберем чуть позже.

Откройте файл `pkg/models/mysql/snippets.go` и обновите его следующим образом:

pkg/models/mysql/snippets.go

```sql
package mysql

import (
	"database/sql"
	"golangify.com/snippetbox/pkg/models"
)

// SnippetModel - Определяем тип который обертывает пул подключения sql.DB
type SnippetModel struct {
	DB *sql.DB
}

// Insert - Метод для создания новой заметки в базе дынных.
func (m *SnippetModel) Insert(title, content, expires string) (int, error) {
	// Ниже будет SQL запрос, который мы хотим выполнить. Мы разделили его на две строки
	// для удобства чтения (поэтому он окружен обратными кавычками
	// вместо обычных двойных кавычек).
	stmt := `INSERT INTO snippets (title, content, created, expires)
    VALUES(?, ?, UTC_TIMESTAMP(), DATE_ADD(UTC_TIMESTAMP(), INTERVAL ? DAY))`

	// Используем метод Exec() из встроенного пула подключений для выполнения
	// запроса. Первый параметр это сам SQL запрос, за которым следует
	// заголовок заметки, содержимое и срока жизни заметки. Этот
	// метод возвращает объект sql.Result, который содержит некоторые основные
	// данные о том, что произошло после выполнении запроса.
	result, err := m.DB.Exec(stmt, title, content, expires)
	if err != nil {
		return 0, err
	}

	// Используем метод LastInsertId(), чтобы получить последний ID
	// созданной записи из таблицу snippets.
	id, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}

	// Возвращаемый ID имеет тип int64, поэтому мы конвертируем его в тип int
	// перед возвратом из метода.
	return int(id), nil
}

// Get - Метод для возвращения данных заметки по её идентификатору ID.
func (m *SnippetModel) Get(id int) (*models.Snippet, error) {
	return nil, nil
}

// Latest - Метод возвращает 10 наиболее часто используемые заметки.
func (m *SnippetModel) Latest() ([]*models.Snippet, error) {
	return nil, nil
}
```
Давайте быстро разберем интерфейс [sql.Result](https://golang.org/pkg/database/sql/#Result), который мы получаем после выполнения `DB.Exec()`. Он предоставляет два метода:

-   `LastInsertId()` возвращает целое число (`int64`), сгенерированное базой данных в ответ на выполненную команду вставки. Обычно это происходит в столбце `id` с «автоматическим инкрементом» при создании новой записи. Это наш случай;
-   `RowsAffected()` возвращает количество строк (в виде `int64`), которые были как-то затронуты (изменены) после выполненных действий.

> **Важно**: Не все [драйверы](https://golangs.org/go-sql-driver-mysql "mysql драйвер golang") и базы данных поддерживают методы `LastInsertId()` и `RowsAffected()`. Например, `LastInsertId()` [не поддерживается](https://github.com/lib/pq/issues/24) в **PostgreSQL**. Если вы планируете использовать данные методы, то нужно сначала проверить документацию для вашего драйвера.

Но, лучше всего игнорировать возвращаемое значение из `sql.Result`, если оно вам не нужно. Делается это таким образом:

```sql
_, err := m.DB.Exec("INSERT INTO ...", ...)
```
## Использование модели базы данных в обработчиках

Давайте вернемся к чему-то более конкретному и продемонстрируем, как вызывать методы моделей из наших [обработчиков](https://golangs.org/url-query-strings "маршрутизация http запросов"). Откройте файл `cmd/web/handlers.go` и обновите обработчик `createSnippet` следующим образом:

```sql
func (app *application) createSnippet(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.Header().Set("Allow", http.MethodPost)
		app.clientError(w, http.StatusMethodNotAllowed)
		return
	}

	// Создаем несколько переменных, содержащих тестовые данные. Мы удалим их позже.
	title := "История про улитку"
	content := "Улитка выползла из раковины,\nвытянула рожки,\nи опять подобрала их."
	expires := "7"

	// Передаем данные в метод SnippetModel.Insert(), получая обратно
	// ID только что созданной записи в базу данных.
	id, err := app.snippets.Insert(title, content, expires)
	if err != nil {
		app.serverError(w, err)
		return
	}

	// Перенаправляем пользователя на соответствующую страницу заметки.
	http.Redirect(w, r, fmt.Sprintf("/snippet?id=%d", id), http.StatusSeeOther)
}
```
Запустите веб-приложение из терминала:

```shell
go run ./cmd/web
```

Затем откройте второе окно терминала и используйте `curl`, чтобы сделать запрос `POST /snippet/create`. Обратите внимание, что флаг `-L` указывает curl на автоматическое выполнение перенаправления. Наше приложение в конце выполняет редирект на страницу заметки.

```shell
$ curl -iL -X POST http://127.0.0.1:4000/snippet/create
```
Результат:

```shell
HTTP/1.1 303 See Other
Location: /snippet?id=4
Date: Wed, 21 Apr 2021 14:39:12 GMT
Content-Length: 0

HTTP/1.1 200 OK
Date: Wed, 21 Apr 2021 14:39:12 GMT
Content-Length: 101
Content-Type: text/plain; charset=utf-8

Отображение определенной заметки с идентификатором 4...
```
Все работает довольно хорошо. Мы только что отправили **HTTP запрос**, который запустил обработчик `createSnippet`, который вызвал метод `SnippetModel.Insert()`. Он вставил новую запись в базу данных и вернул ID этой новой записи. Затем обработчик перенаправил на другой адрес с ID в конце URL строки.

Можете взглянуть на содержимое таблицы `snippets` из базы данных MySQL.

Зайдите в MySQL через терминал:

```shell
mysql -u root -p
```

Используйте пароль который вы указали при [установки MySQL](https://golangs.org/mysql-web-site "MySQL Golang").

Выбираем базу данных:

```shell
mysql> SELECT id, title, expires FROM snippets;
```
Выполняем **SELECT** запрос, чтобы получить весь список заметок из таблицы:

<table><tbody><tr><td data-settings="show"></td><td><div><p><span>mysql</span><span>&gt;</span><span> </span><span>SELECT </span><span>id</span><span>,</span><span> </span><span>title</span><span>,</span><span> </span><span>expires </span><span>FROM </span><span>snippets</span><span>;</span></p></div></td></tr></tbody></table>

Результат:

```shell
+----+---------------------------------------------+---------------------+
| id | title                                       | expires             |
+----+---------------------------------------------+---------------------+
|  1 | Не имей сто рублей                          | 2022-01-27 13:09:34 |
|  2 | Лучше один раз увидеть                      | 2022-01-27 13:09:40 |
|  3 | Не откладывай на завтра                     | 2021-02-03 13:09:44 |
|  4 | История про улитку                          | 2021-04-28 14:39:12 |
+----+---------------------------------------------+---------------------+
4 rows in set (0.00 sec)
```
Вот и наша запись в конце под номером 4.

## Использования плейсхолдеров для SQL запросов

В приведенном выше коде мы составили SQL запрос, используя плейсхолдеры, где знак `?` выступал в качестве плейсхолдера для данных, которые требуется вставить.

> Топорный перевод для **плейсхолдера** будет «*придержи мне место*» под будущие данные.

Причина использования плейсхолдера для построения запроса (а не интерполяции [строк](https://golangs.org/string "строки в golang")) заключается в том, что любые данные которые нужно вставить в базу данных нужно сперва «подготовить» прежде чем выполнить запрос. Даже если пользователь вместо заголовка заметки отправит какой-то вредоносный SQL запрос (**SQL инъекция**), то используя плейсхолдеры, эти запросы не навредят базе данных.

Под «капотом», метод `DB.Exec()` работает в три этапа:

1.  Он создает новый [подготовленный запрос](https://en.wikipedia.org/wiki/Prepared_statement) в базу данных, используя предоставленный SQL оператор. База данных парсирует и компилирует запрос, а затем хранит его готовым к выполнению;
2.  На втором шаге, `Exec()` передает значения параметров в базу данных. Затем база данных выполняет подготовленный запрос, используя эти параметры. Параметры передаются позже, поэтому после компиляции запроса, база данных рассматривает их как чистые данные. Они не могут изменить цель оператора. До тех пор, пока исходный оператор получен из ненадежных данных, инъекция не может произойти;
3.  Затем он закрывает подготовленный запрос к базе данных.

Синтаксис **параметра плейсхоледера** различается в зависимости от базы данных. MySQL, SQL Server и SQLite используют символ `?`, но PostgreSQL использует `$N`. К примеру , если бы вы использовали PostgreSQL, вы бы создали запись таким образом:

```go
_, err := m.DB.Exec("INSERT INTO ... VALUES ($1, $2, $3)", ...)
```
### Исходный код

**Скачать**: [snippetbox-19.zip](https://golangs.org/wp-content/uploads/2021/04/snippetbox-19.zip)

![](https://golangify.com/wp-content/uploads/2021/01/v.jpg)
